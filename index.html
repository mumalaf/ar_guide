<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Simple WebAR - GLB Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: -1;
      }

      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: auto;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        z-index: 100;
      }

      #controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
      }

      button {
        padding: 10px 15px;
        background: rgba(0, 0, 0, 0.7);
        border: none;
        color: white;
        border-radius: 5px;
        cursor: pointer;
      }

      button:hover {
        background: rgba(0, 0, 0, 0.9);
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  </head>

  <body>
    <video id="video" autoplay muted playsinline></video>

    <div id="info">
      WebAR 상태: <span id="status">초기화 중...</span><br />
      조작: 터치/드래그하여 객체 이동
    </div>

    <div id="controls">
      <button onclick="resetObjectPosition()">객체 리셋</button>
    </div>

    <script>
      let scene, camera, renderer;
      let model; // 3D 모델
      let video;
      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();
      let selectedObject = null;
      let isDragging = false;
      let offset = new THREE.Vector3();
      let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      let intersectPoint = new THREE.Vector3();

      // 상태 업데이트 함수
      function updateStatus(message) {
        document.getElementById('status').textContent = message;
      }

      // 초기화
      init();
      animate();

      async function init() {
        // Three.js 설정
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 5;

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          preserveDrawingBuffer: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0); // 투명 배경
        document.body.appendChild(renderer.domElement);

        // 윈도우 리사이즈 이벤트
        window.addEventListener('resize', onWindowResize);

        // 웹캠 초기화
        await initCamera();

        // GLB 모델 로드
        await loadModel();

        // 조명 설정
        setupLights();

        // 이벤트 리스너
        setupEventListeners();

        updateStatus('준비 완료');
      }

      async function initCamera() {
        try {
          video = document.getElementById('video');

          const constraints = {
            video: {
              facingMode: 'environment', // 후면 카메라 사용
              width: { ideal: 1280 },
              height: { ideal: 720 },
            },
          };

          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;

          video.addEventListener('loadedmetadata', () => {
            updateStatus('카메라 활성화됨');
          });
        } catch (error) {
          console.error('카메라 초기화 실패:', error);
          updateStatus('카메라 접근 실패');
          // 카메라 없이도 동작하도록 배경색 설정
          document.body.style.background =
            'linear-gradient(45deg, #667eea 0%, #764ba2 100%)';
        }
      }

      async function loadModel() {
        updateStatus('모델 로드 중...');
        const loader = new THREE.GLTFLoader();
        try {
          const gltf = await loader.loadAsync(
            'lib/three.js-master/files/honey3d.glb' // GLB 파일 경로
          );
          model = gltf.scene;
          model.position.set(0, 0, 0);
          model.scale.set(1, 1, 1); // 필요에 따라 크기 조정
          scene.add(model);
          updateStatus('모델 로드 완료');
        } catch (error) {
          console.error('GLB 모델 로드 실패:', error);
          updateStatus('모델 로드 실패 - GLB 파일 경로를 확인하세요');
        }
      }

      function setupLights() {
        // 주변광
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // 방향광
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
      }

      function setupEventListeners() {
        // 마우스/터치 이벤트
        renderer.domElement.addEventListener('mousedown', onPointerDown);
        renderer.domElement.addEventListener('mousemove', onPointerMove);
        renderer.domElement.addEventListener('mouseup', onPointerUp);
        renderer.domElement.addEventListener('touchstart', onPointerDown);
        renderer.domElement.addEventListener('touchmove', onPointerMove);
        renderer.domElement.addEventListener('touchend', onPointerUp);
      }

      function getIntersects(event) {
        const rect = renderer.domElement.getBoundingClientRect();

        if (event.touches && event.touches.length > 0) {
          mouse.x =
            ((event.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y =
            -((event.touches[0].clientY - rect.top) / rect.height) * 2 + 1;
        } else {
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        raycaster.setFromCamera(mouse, camera);
        if (model) {
          return raycaster.intersectObject(model, true);
        }
        return [];
      }

      function onPointerDown(event) {
        event.preventDefault();
        const intersects = getIntersects(event);
        if (intersects.length > 0) {
          selectedObject = model;
          isDragging = true;

          plane.setFromNormalAndCoplanarPoint(
            camera.getWorldDirection(plane.normal),
            selectedObject.position
          );
          raycaster.ray.intersectPlane(plane, intersectPoint);
          offset.copy(intersectPoint).sub(selectedObject.position);
        }
      }

      function onPointerMove(event) {
        if (!isDragging || !selectedObject) return;

        event.preventDefault();
        const rect = renderer.domElement.getBoundingClientRect();

        if (event.touches && event.touches.length > 0) {
          mouse.x =
            ((event.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y =
            -((event.touches[0].clientY - rect.top) / rect.height) * 2 + 1;
        } else {
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        raycaster.setFromCamera(mouse, camera);
        raycaster.ray.intersectPlane(plane, intersectPoint);
        selectedObject.position.copy(intersectPoint.sub(offset));
      }

      function onPointerUp(event) {
        isDragging = false;
        selectedObject = null;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // 객체 위치 리셋
      function resetObjectPosition() {
        if (model) {
          model.position.set(0, 0, 0);
          model.rotation.set(0, 0, 0);
          updateStatus('객체 위치 리셋됨');
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
