<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Enhanced WebAR - GLB Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: -1;
      }

      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: auto;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        z-index: 100;
        max-width: 200px;
      }

      #controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }

      #topControls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        display: flex;
        gap: 10px;
      }

      button {
        padding: 10px 15px;
        background: rgba(0, 0, 0, 0.7);
        border: none;
        color: white;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        white-space: nowrap;
      }

      button:hover {
        background: rgba(0, 0, 0, 0.9);
      }

      button:disabled {
        background: rgba(0, 0, 0, 0.4);
        cursor: not-allowed;
      }

      .capture-btn {
        background: rgba(255, 59, 48, 0.8);
        font-size: 16px;
        padding: 15px 20px;
      }

      .capture-btn:hover {
        background: rgba(255, 59, 48, 1);
      }

      #downloadLink {
        position: absolute;
        top: -1000px;
        left: -1000px;
      }

      .status-success {
        color: #4CAF50;
      }

      .status-error {
        color: #FF5722;
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  </head>

  <body>
    <video id="video" autoplay muted playsinline></video>

    <div id="info">
      WebAR ìƒíƒœ: <span id="status">ì´ˆê¸°í™” ì¤‘...</span><br />
      ì¹´ë©”ë¼: <span id="cameraType">í›„ë©´</span><br />
      ì¡°ì‘: í„°ì¹˜/ë“œë˜ê·¸í•˜ì—¬ ê°ì²´ ì´ë™
    </div>

    <div id="topControls">
      <button id="switchCameraBtn" onclick="switchCamera()">ğŸ“· ì¹´ë©”ë¼ ì „í™˜</button>
    </div>

    <div id="controls">
      <button onclick="resetObjectPosition()">ğŸ”„ ê°ì²´ ë¦¬ì…‹</button>
      <button class="capture-btn" onclick="captureScreen()">ğŸ“¸ í™”ë©´ ìº¡ì²˜</button>
    </div>

    <a id="downloadLink" download="webAR_capture.png"></a>

    <script>
      let scene, camera, renderer;
      let model; // 3D ëª¨ë¸
      let video;
      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();
      let selectedObject = null;
      let isDragging = false;
      let offset = new THREE.Vector3();
      let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      let intersectPoint = new THREE.Vector3();
      
      // ì¹´ë©”ë¼ ê´€ë ¨ ë³€ìˆ˜
      let currentFacingMode = 'environment'; // 'environment' ë˜ëŠ” 'user'
      let availableCameras = [];
      let currentStream = null;

      // ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
      function updateStatus(message, type = 'normal') {
        const statusElement = document.getElementById('status');
        statusElement.textContent = message;
        statusElement.className = type === 'success' ? 'status-success' : 
                                 type === 'error' ? 'status-error' : '';
      }

      // ì¹´ë©”ë¼ íƒ€ì… ì—…ë°ì´íŠ¸
      function updateCameraType() {
        document.getElementById('cameraType').textContent = 
          currentFacingMode === 'environment' ? 'í›„ë©´' : 'ì „ë©´';
      }

      // ì´ˆê¸°í™”
      init();
      animate();

      async function init() {
        // Three.js ì„¤ì •
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 5;

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          preserveDrawingBuffer: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0); // íˆ¬ëª… ë°°ê²½
        document.body.appendChild(renderer.domElement);

        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸
        window.addEventListener('resize', onWindowResize);

        // ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë©”ë¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        await getAvailableCameras();

        // ì›¹ìº  ì´ˆê¸°í™”
        await initCamera();

        // GLB ëª¨ë¸ ë¡œë“œ (ë°ëª¨ìš© íë¸Œë¡œ ëŒ€ì²´)
        await loadModel();

        // ì¡°ëª… ì„¤ì •
        setupLights();

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        setupEventListeners();

        updateStatus('ì¤€ë¹„ ì™„ë£Œ', 'success');
      }

      async function getAvailableCameras() {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          availableCameras = devices.filter(device => device.kind === 'videoinput');
          
          // ì¹´ë©”ë¼ ì „í™˜ ë²„íŠ¼ í™œì„±í™”/ë¹„í™œì„±í™”
          const switchBtn = document.getElementById('switchCameraBtn');
          switchBtn.disabled = availableCameras.length < 2;
          
          console.log(`ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë©”ë¼: ${availableCameras.length}ê°œ`);
        } catch (error) {
          console.error('ì¹´ë©”ë¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
        }
      }

      async function initCamera() {
        try {
          video = document.getElementById('video');

          const constraints = {
            video: {
              facingMode: currentFacingMode,
              width: { ideal: 1280 },
              height: { ideal: 720 },
            },
          };

          // ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
          if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
          }

          currentStream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = currentStream;

          video.addEventListener('loadedmetadata', () => {
            updateStatus('ì¹´ë©”ë¼ í™œì„±í™”ë¨', 'success');
            updateCameraType();
          });
        } catch (error) {
          console.error('ì¹´ë©”ë¼ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
          updateStatus('ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨', 'error');
          // ì¹´ë©”ë¼ ì—†ì´ë„ ë™ì‘í•˜ë„ë¡ ë°°ê²½ìƒ‰ ì„¤ì •
          document.body.style.background =
            'linear-gradient(45deg, #667eea 0%, #764ba2 100%)';
        }
      }

      // ì¹´ë©”ë¼ ì „í™˜ í•¨ìˆ˜
      async function switchCamera() {
        if (availableCameras.length < 2) {
          updateStatus('ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë©”ë¼ê°€ í•˜ë‚˜ë¿ì…ë‹ˆë‹¤', 'error');
          return;
        }

        updateStatus('ì¹´ë©”ë¼ ì „í™˜ ì¤‘...');
        
        // ì¹´ë©”ë¼ ëª¨ë“œ ì „í™˜
        currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
        
        try {
          await initCamera();
          updateStatus('ì¹´ë©”ë¼ ì „í™˜ ì™„ë£Œ', 'success');
        } catch (error) {
          console.error('ì¹´ë©”ë¼ ì „í™˜ ì‹¤íŒ¨:', error);
          updateStatus('ì¹´ë©”ë¼ ì „í™˜ ì‹¤íŒ¨', 'error');
          // ì›ë˜ ëª¨ë“œë¡œ ë˜ëŒë¦¬ê¸°
          currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
        }
      }

      async function loadModel() {
        updateStatus('ëª¨ë¸ ë¡œë“œ ì¤‘...');
        
        // GLB íŒŒì¼ì´ ì—†ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ë°ëª¨ìš© íë¸Œ ìƒì„±
        try {
          const loader = new THREE.GLTFLoader();
          const gltf = await loader.loadAsync(
            'lib/three.js-master/files/honey3d.glb' // GLB íŒŒì¼ ê²½ë¡œ
          );
          model = gltf.scene;
          model.position.set(0, 0, 0);
          model.scale.set(1, 1, 1);
          scene.add(model);
          updateStatus('ëª¨ë¸ ë¡œë“œ ì™„ë£Œ', 'success');
        } catch (error) {
          console.error('GLB ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:', error);
          updateStatus('GLB ë¡œë“œ ì‹¤íŒ¨ - ë°ëª¨ íë¸Œ ì‚¬ìš©');
          
          // ë°ëª¨ìš© íë¸Œ ìƒì„±
          const geometry = new THREE.BoxGeometry(1, 1, 1);
          const material = new THREE.MeshPhongMaterial({ 
            color: 0x00ff00,
            transparent: true,
            opacity: 0.8
          });
          model = new THREE.Mesh(geometry, material);
          model.position.set(0, 0, 0);
          scene.add(model);
        }
      }

      function setupLights() {
        // ì£¼ë³€ê´‘
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // ë°©í–¥ê´‘
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
      }

      function setupEventListeners() {
        // ë§ˆìš°ìŠ¤/í„°ì¹˜ ì´ë²¤íŠ¸
        renderer.domElement.addEventListener('mousedown', onPointerDown);
        renderer.domElement.addEventListener('mousemove', onPointerMove);
        renderer.domElement.addEventListener('mouseup', onPointerUp);
        renderer.domElement.addEventListener('touchstart', onPointerDown);
        renderer.domElement.addEventListener('touchmove', onPointerMove);
        renderer.domElement.addEventListener('touchend', onPointerUp);
      }

      function getIntersects(event) {
        const rect = renderer.domElement.getBoundingClientRect();

        if (event.touches && event.touches.length > 0) {
          mouse.x =
            ((event.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y =
            -((event.touches[0].clientY - rect.top) / rect.height) * 2 + 1;
        } else {
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        raycaster.setFromCamera(mouse, camera);
        if (model) {
          return raycaster.intersectObject(model, true);
        }
        return [];
      }

      function onPointerDown(event) {
        event.preventDefault();
        const intersects = getIntersects(event);
        if (intersects.length > 0) {
          selectedObject = model;
          isDragging = true;

          plane.setFromNormalAndCoplanarPoint(
            camera.getWorldDirection(plane.normal),
            selectedObject.position
          );
          raycaster.ray.intersectPlane(plane, intersectPoint);
          offset.copy(intersectPoint).sub(selectedObject.position);
        }
      }

      function onPointerMove(event) {
        if (!isDragging || !selectedObject) return;

        event.preventDefault();
        const rect = renderer.domElement.getBoundingClientRect();

        if (event.touches && event.touches.length > 0) {
          mouse.x =
            ((event.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y =
            -((event.touches[0].clientY - rect.top) / rect.height) * 2 + 1;
        } else {
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        raycaster.setFromCamera(mouse, camera);
        raycaster.ray.intersectPlane(plane, intersectPoint);
        selectedObject.position.copy(intersectPoint.sub(offset));
      }

      function onPointerUp(event) {
        isDragging = false;
        selectedObject = null;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // ê°ì²´ ìœ„ì¹˜ ë¦¬ì…‹
      function resetObjectPosition() {
        if (model) {
          model.position.set(0, 0, 0);
          model.rotation.set(0, 0, 0);
          updateStatus('ê°ì²´ ìœ„ì¹˜ ë¦¬ì…‹ë¨', 'success');
        }
      }

      // í™”ë©´ ìº¡ì²˜ ê¸°ëŠ¥
      function captureScreen() {
        try {
          updateStatus('í™”ë©´ ìº¡ì²˜ ì¤‘...');
          
          // ìº”ë²„ìŠ¤ì—ì„œ ì´ë¯¸ì§€ ë°ì´í„° ì¶”ì¶œ
          const canvas = renderer.domElement;
          
          // ìº”ë²„ìŠ¤ë¥¼ ì´ë¯¸ì§€ë¡œ ë³€í™˜
          canvas.toBlob(function(blob) {
            if (blob) {
              // íŒŒì¼ëª… ìƒì„± (íƒ€ì„ìŠ¤íƒ¬í”„ í¬í•¨)
              const timestamp = new Date().toISOString()
                .replace(/[:.]/g, '-')
                .split('.')[0];
              const filename = `webAR_capture_${timestamp}.png`;
              
              // ë‹¤ìš´ë¡œë“œ ë§í¬ ìƒì„±
              const downloadLink = document.getElementById('downloadLink');
              const url = URL.createObjectURL(blob);
              downloadLink.href = url;
              downloadLink.download = filename;
              
              // ëª¨ë°”ì¼ì—ì„œ ê°¤ëŸ¬ë¦¬ ì €ì¥ì„ ì‹œë„
              if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([blob], filename, { type: 'image/png' })] })) {
                // Web Share API ì‚¬ìš© (ëª¨ë°”ì¼)
                const file = new File([blob], filename, { type: 'image/png' });
                navigator.share({
                  files: [file],
                  title: 'WebAR ìº¡ì²˜',
                  text: 'WebARì—ì„œ ìº¡ì²˜í•œ ì´ë¯¸ì§€ì…ë‹ˆë‹¤.'
                }).then(() => {
                  updateStatus('ì´ë¯¸ì§€ ê³µìœ  ì™„ë£Œ', 'success');
                }).catch((error) => {
                  console.error('ê³µìœ  ì‹¤íŒ¨:', error);
                  // ê³µìœ  ì‹¤íŒ¨ ì‹œ ë‹¤ìš´ë¡œë“œë¡œ ëŒ€ì²´
                  downloadLink.click();
                  updateStatus('ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ', 'success');
                });
              } else {
                // ì¼ë°˜ ë‹¤ìš´ë¡œë“œ
                downloadLink.click();
                updateStatus('ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ', 'success');
                
                // ëª¨ë°”ì¼ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ì‚¬ìš©ìì—ê²Œ ê°¤ëŸ¬ë¦¬ ì €ì¥ ì•ˆë‚´
                if (isMobile()) {
                  setTimeout(() => {
                    updateStatus('ë‹¤ìš´ë¡œë“œ í´ë” ë˜ëŠ” ê°¤ëŸ¬ë¦¬ë¥¼ í™•ì¸í•˜ì„¸ìš”');
                  }, 2000);
                }
              }
              
              // URL ì •ë¦¬
              setTimeout(() => {
                URL.revokeObjectURL(url);
              }, 1000);
            } else {
              updateStatus('ìº¡ì²˜ ì‹¤íŒ¨: Blob ìƒì„± ì˜¤ë¥˜', 'error');
            }
          }, 'image/png', 0.95);
          
        } catch (error) {
          console.error('í™”ë©´ ìº¡ì²˜ ì‹¤íŒ¨:', error);
          updateStatus('í™”ë©´ ìº¡ì²˜ ì‹¤íŒ¨', 'error');
        }
      }

      // ëª¨ë°”ì¼ ë””ë°”ì´ìŠ¤ ê°ì§€
      function isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      }

      function animate() {
        requestAnimationFrame(animate);
        
        // ëª¨ë¸ ìë™ íšŒì „ (ì„ íƒì‚¬í•­)
        if (model && !isDragging) {
          model.rotation.y += 0.005;
        }
        
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
